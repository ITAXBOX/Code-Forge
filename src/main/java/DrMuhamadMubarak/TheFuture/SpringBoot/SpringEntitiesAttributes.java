package DrMuhamadMubarak.TheFuture.SpringBoot;

import DrMuhamadMubarak.TheFuture.Generator.DTO.AttributeDTO;
import org.springframework.util.StringUtils;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class SpringEntitiesAttributes {
    public static void generateOrUpdateSpringEntityClass(String projectName, String entityName, AttributeDTO attribute) throws IOException {
        String baseDir = "./" + projectName + "/src/main/java/com/example/" + projectName.toLowerCase() + "/models";
        Path entityFilePath = Paths.get(baseDir, entityName + ".java");

        if (!Files.exists(entityFilePath)) {
            throw new IOException("File not found: " + entityFilePath);
        }

        String entityContent = Files.readString(entityFilePath);
        StringBuilder updatedContent = new StringBuilder(entityContent);

        int classEndIndex = entityContent.lastIndexOf("}");
        if (classEndIndex == -1) {
            throw new IllegalStateException("Class end not found in file: " + entityFilePath);
        }

        String attributeField = generateFieldForAttribute(attribute, entityName);
        updatedContent.insert(classEndIndex, attributeField);

        Files.writeString(entityFilePath, updatedContent.toString());
    }

    private static String generateFieldForAttribute(AttributeDTO attribute, String entityName) {
        StringBuilder field = new StringBuilder();

        if (attribute.getRelationshipType() != null && !attribute.getRelationshipType().equalsIgnoreCase("NONE")) {
            field.append(generateRelationshipAnnotations(attribute, entityName)).append("\n");
        }

        if (attribute.isPrimaryKey()) {
            field.append("\n    @Id");
            if (attribute.isAutoGenerated()) {
                field.append("\n    @GeneratedValue(strategy = GenerationType.IDENTITY)");
            }
        }
        StringBuilder columnAnnotation = new StringBuilder("@Column(");

        boolean hasLength = attribute.getDataSize() != null && !attribute.getDataSize().isEmpty();
        boolean isNullable = attribute.isNullable();
        boolean hasDefaultValue = attribute.getDefaultValue() != null && !attribute.getDefaultValue().isEmpty();
        boolean hasAttributes = false;
        String dataType = formatDataType(attribute);

        if ("String".equalsIgnoreCase(attribute.getDataType()) && hasLength) {
            columnAnnotation.append("length = ").append(attribute.getDataSize());
            hasAttributes = true;
        }

        if (!isNullable) {
            if (hasAttributes) {
                columnAnnotation.append(", ");
            }
            columnAnnotation.append("nullable = false");
            hasAttributes = true;
        }

        if (hasDefaultValue) {
            if (hasAttributes) {
                columnAnnotation.append(", ");
            }
            if (dataType.contains("=")) {
                columnAnnotation.append("columnDefinition = \"").append(dataType.split("=")[0])
                        .append(" default '").append(attribute.getDefaultValue()).append("'\"");
            } else {
                columnAnnotation.append("columnDefinition = \"").append(dataType)
                        .append(" default '").append(attribute.getDefaultValue()).append("'\"");
            }
            hasAttributes = true;
        }

        columnAnnotation.append(")");

        if (hasAttributes) {
            field.append("\n    ").append(columnAnnotation);
        }

        if (!"String".equalsIgnoreCase(attribute.getDataType()) && hasLength)
            field.append("\n    ").append("@Max(").append(attribute.getDataSize()).append(")");


        if (dataType.contains("=")) {
            field.append("\n    private ").append(dataType.split("=")[0]).append(" ").append(attribute.getAttributeName());
            field.append("=").append(dataType.split("=")[1]);
        } else {
            field.append("\n    private ").append(dataType).append(" ").append(attribute.getAttributeName());
        }

        field.append(";");

        field.append("\n");

        return field.toString();
    }

    private static String formatDataType(AttributeDTO attribute) {
        String dataType = attribute.getDataType();
        if (dataType == null || dataType.isEmpty()) {
            throw new IllegalArgumentException("DataType cannot be null or empty for attribute: " + attribute.getAttributeName());
        }

        return switch (dataType.toUpperCase()) {
            case "STRING" -> "String";
            case "INTEGER" -> attribute.isNullable() ? "Integer" : "int";
            case "LONG" -> attribute.isNullable() ? "Long" : "long";
            case "DATE" -> "LocalDateTime";
            case "BOOLEAN" -> attribute.isNullable() ? "Boolean" : "boolean";
            case "DOUBLE" -> attribute.isNullable() ? "Double" : "double";
            default -> dataType;
        };
    }

    private static String generateRelationshipAnnotations(AttributeDTO attribute, String entityName) {
        StringBuilder annotation = new StringBuilder();
        String relationshipType = attribute.getRelationshipType().toUpperCase();

        switch (relationshipType) {
            case "MANY_TO_ONE":
                annotation.append("@ManyToOne\n")
                        .append("    @JoinColumn(name = \"")
                        .append(StringUtils.uncapitalize(attribute.getRelatedEntity()))
                        .append("_id\")");
                break;

            case "ONE_TO_MANY":
                if (attribute.getMappedBy() == null || attribute.getMappedBy().isEmpty()) {
                    throw new IllegalArgumentException("One-to-Many relationship requires 'mappedBy' field");
                }
                annotation.append("@OneToMany(mappedBy = \"")
                        .append(attribute.getMappedBy()).append("\")");
                break;

            case "ONE_TO_ONE":
                if (attribute.getMappedBy() != null && !attribute.getMappedBy().isEmpty()) {
                    annotation.append("@OneToOne(mappedBy = \"")
                            .append(attribute.getMappedBy()).append("\")");
                } else {
                    annotation.append("@OneToOne\n")
                            .append("    @JoinColumn(name = \"")
                            .append(StringUtils.uncapitalize(attribute.getRelatedEntity()))
                            .append("_id\")");
                }
                break;

            case "MANY_TO_MANY":
                if (attribute.getMappedBy() != null && !attribute.getMappedBy().isEmpty()) {
                    annotation.append("@ManyToMany(mappedBy = \"")
                            .append(attribute.getMappedBy()).append("\")");
                } else {
                    annotation.append("@ManyToMany\n")
                            .append("    @JoinTable(name = \"")
                            .append(StringUtils.uncapitalize(entityName))
                            .append("_")
                            .append(StringUtils.uncapitalize(attribute.getRelatedEntity()))
                            .append("\",\n")
                            .append("        joinColumns = @JoinColumn(name = \"")
                            .append(StringUtils.uncapitalize(entityName))
                            .append("_id\"),\n")
                            .append("        inverseJoinColumns = @JoinColumn(name = \"")
                            .append(StringUtils.uncapitalize(attribute.getRelatedEntity()))
                            .append("_id\"))");
                }
                break;

            default:
                throw new IllegalArgumentException("Invalid relationship type: " + relationshipType);
        }

        return annotation.toString();
    }


}
