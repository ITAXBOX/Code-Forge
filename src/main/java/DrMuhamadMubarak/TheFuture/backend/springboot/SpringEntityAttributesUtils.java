package DrMuhamadMubarak.TheFuture.backend.springboot;

import DrMuhamadMubarak.TheFuture.generator.dto.AttributeDTO;
import org.springframework.util.StringUtils;

/**
 * Utility class containing helper methods and constants for Spring entity attribute generation.
 * This class provides utility functions for data type formatting, relationship annotations,
 * and field generation for JPA entities.
 */
public class SpringEntityAttributesUtils {

    // Data type mappings for Java types
    private static final String DEFAULT_STRING_TYPE = "String";
    private static final String DEFAULT_INTEGER_TYPE = "Integer";
    private static final String DEFAULT_LONG_TYPE = "Long";
    private static final String DEFAULT_DATE_TYPE = "LocalDateTime";
    private static final String DEFAULT_BOOLEAN_TYPE = "Boolean";
    private static final String DEFAULT_DOUBLE_TYPE = "Double";

    // Primitive type mappings
    private static final String PRIMITIVE_INTEGER_TYPE = "int";
    private static final String PRIMITIVE_LONG_TYPE = "long";
    private static final String PRIMITIVE_BOOLEAN_TYPE = "boolean";
    private static final String PRIMITIVE_DOUBLE_TYPE = "double";

    /**
     * Generates a complete field declaration for an attribute including annotations.
     */
    public static String generateFieldForAttribute(AttributeDTO attribute, String entityName) {
        StringBuilder field = new StringBuilder();

        if (attribute.getRelationshipType() != null && !attribute.getRelationshipType().equalsIgnoreCase("NONE")) {
            field.append(generateRelationshipAnnotations(attribute, entityName)).append("\n");
        }

        if (attribute.isPrimaryKey()) {
            field.append(generatePrimaryKeyAnnotations(attribute));
        }

        String columnAnnotation = generateColumnAnnotation(attribute);
        if (!columnAnnotation.isEmpty()) {
            field.append("\n    ").append(columnAnnotation);
        }

        String validationAnnotation = generateValidationAnnotations(attribute);
        if (!validationAnnotation.isEmpty()) {
            field.append(validationAnnotation);
        }

        field.append(generateFieldDeclaration(attribute));
        field.append("\n");

        return field.toString();
    }

    /**
     * Generates primary key annotations (@Id and @GeneratedValue).
     */
    public static String generatePrimaryKeyAnnotations(AttributeDTO attribute) {
        StringBuilder annotations = new StringBuilder("\n    @Id");
        if (attribute.isAutoGenerated()) {
            annotations.append("\n    @GeneratedValue(strategy = GenerationType.IDENTITY)");
        }
        return annotations.toString();
    }

    /**
     * Generates @Column annotation with appropriate attributes.
     */
    public static String generateColumnAnnotation(AttributeDTO attribute) {
        StringBuilder columnAnnotation = new StringBuilder("@Column(");

        boolean hasLength = attribute.getDataSize() != null && !attribute.getDataSize().isEmpty();
        boolean isNullable = attribute.isNullable();
        boolean hasDefaultValue = attribute.getDefaultValue() != null && !attribute.getDefaultValue().isEmpty();
        boolean hasAttributes = false;
        String dataType = formatDataType(attribute);

        if (isStringType(attribute.getDataType()) && hasLength) {
            columnAnnotation.append("length = ").append(attribute.getDataSize());
            hasAttributes = true;
        }

        if (!isNullable) {
            if (hasAttributes) {
                columnAnnotation.append(", ");
            }
            columnAnnotation.append("nullable = false");
            hasAttributes = true;
        }

        if (hasDefaultValue) {
            if (hasAttributes) {
                columnAnnotation.append(", ");
            }
            columnAnnotation.append(generateDefaultValueClause(dataType, attribute.getDefaultValue()));
            hasAttributes = true;
        }

        columnAnnotation.append(")");

        return hasAttributes ? columnAnnotation.toString() : "";
    }

    /**
     * Generates validation annotations like @Max.
     */
    public static String generateValidationAnnotations(AttributeDTO attribute) {
        StringBuilder validations = new StringBuilder();

        boolean hasLength = attribute.getDataSize() != null && !attribute.getDataSize().isEmpty();
        if (!isStringType(attribute.getDataType()) && hasLength) {
            validations.append("\n    ").append("@Max(").append(attribute.getDataSize()).append(")");
        }

        return validations.toString();
    }

    /**
     * Generates the actual field declaration with type and name.
     */
    public static String generateFieldDeclaration(AttributeDTO attribute) {
        StringBuilder field = new StringBuilder();
        String dataType = formatDataType(attribute);

        if (dataType.contains("=")) {
            String[] parts = dataType.split("=", 2);
            field.append("\n    private ").append(parts[0]).append(" ").append(attribute.getAttributeName());
            field.append(" = ").append(parts[1]);
        } else {
            field.append("\n    private ").append(dataType).append(" ").append(attribute.getAttributeName());
        }

        field.append(";");
        return field.toString();
    }

    /**
     * Generates default value clause for column definition.
     */
    public static String generateDefaultValueClause(String dataType, String defaultValue) {
        if (dataType.contains("=")) {
            return "columnDefinition = \"" + dataType.split("=")[0] +
                   " default '" + defaultValue + "'\"";
        } else {
            return "columnDefinition = \"" + dataType +
                   " default '" + defaultValue + "'\"";
        }
    }

    /**
     * Formats the data type according to Java conventions and nullability.
     */
    public static String formatDataType(AttributeDTO attribute) {
        String dataType = attribute.getDataType();
        if (dataType == null || dataType.isEmpty()) {
            throw new IllegalArgumentException("DataType cannot be null or empty for attribute: " + attribute.getAttributeName());
        }

        return switch (dataType.toUpperCase()) {
            case "STRING" -> DEFAULT_STRING_TYPE;
            case "INTEGER" -> attribute.isNullable() ? DEFAULT_INTEGER_TYPE : PRIMITIVE_INTEGER_TYPE;
            case "LONG" -> attribute.isNullable() ? DEFAULT_LONG_TYPE : PRIMITIVE_LONG_TYPE;
            case "DATE" -> DEFAULT_DATE_TYPE;
            case "BOOLEAN" -> attribute.isNullable() ? DEFAULT_BOOLEAN_TYPE : PRIMITIVE_BOOLEAN_TYPE;
            case "DOUBLE" -> attribute.isNullable() ? DEFAULT_DOUBLE_TYPE : PRIMITIVE_DOUBLE_TYPE;
            default -> dataType;
        };
    }

    /**
     * Generates relationship annotations based on the relationship type.
     */
    public static String generateRelationshipAnnotations(AttributeDTO attribute, String entityName) {
        StringBuilder annotation = new StringBuilder();
        String relationshipType = attribute.getRelationshipType().toUpperCase();

        switch (relationshipType) {
            case "MANY_TO_ONE":
                annotation.append(generateManyToOneAnnotation(attribute));
                break;

            case "ONE_TO_MANY":
                annotation.append(generateOneToManyAnnotation(attribute));
                break;

            case "ONE_TO_ONE":
                annotation.append(generateOneToOneAnnotation(attribute));
                break;

            case "MANY_TO_MANY":
                annotation.append(generateManyToManyAnnotation(attribute, entityName));
                break;

            default:
                throw new IllegalArgumentException("Invalid relationship type: " + relationshipType);
        }

        return annotation.toString();
    }

    /**
     * Generates @ManyToOne annotation with join column.
     */
    public static String generateManyToOneAnnotation(AttributeDTO attribute) {
        return "@ManyToOne\n" +
               "    @JoinColumn(name = \"" +
               StringUtils.uncapitalize(attribute.getRelatedEntity()) +
               "_id\")";
    }

    /**
     * Generates @OneToMany annotation with mappedBy.
     */
    public static String generateOneToManyAnnotation(AttributeDTO attribute) {
        if (attribute.getMappedBy() == null || attribute.getMappedBy().isEmpty()) {
            throw new IllegalArgumentException("One-to-Many relationship requires 'mappedBy' field");
        }
        return "@OneToMany(mappedBy = \"" + attribute.getMappedBy() + "\")";
    }

    /**
     * Generates @OneToOne annotation with optional mappedBy or join column.
     */
    public static String generateOneToOneAnnotation(AttributeDTO attribute) {
        if (attribute.getMappedBy() != null && !attribute.getMappedBy().isEmpty()) {
            return "@OneToOne(mappedBy = \"" + attribute.getMappedBy() + "\")";
        } else {
            return "@OneToOne\n" +
                   "    @JoinColumn(name = \"" +
                   StringUtils.uncapitalize(attribute.getRelatedEntity()) +
                   "_id\")";
        }
    }

    /**
     * Generates @ManyToMany annotation with optional mappedBy or join table.
     */
    public static String generateManyToManyAnnotation(AttributeDTO attribute, String entityName) {
        if (attribute.getMappedBy() != null && !attribute.getMappedBy().isEmpty()) {
            return "@ManyToMany(mappedBy = \"" + attribute.getMappedBy() + "\")";
        } else {
            return "@ManyToMany\n" +
                   "    @JoinTable(name = \"" +
                   StringUtils.uncapitalize(entityName) +
                   "_" +
                   StringUtils.uncapitalize(attribute.getRelatedEntity()) +
                   "\",\n" +
                   "        joinColumns = @JoinColumn(name = \"" +
                   StringUtils.uncapitalize(entityName) +
                   "_id\"),\n" +
                   "        inverseJoinColumns = @JoinColumn(name = \"" +
                   StringUtils.uncapitalize(attribute.getRelatedEntity()) +
                   "_id\"))";
        }
    }

    /**
     * Checks if the data type is a String type.
     */
    public static boolean isStringType(String dataType) {
        return "STRING".equalsIgnoreCase(dataType);
    }
}
